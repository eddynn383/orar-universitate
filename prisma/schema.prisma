// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
    provider = "prisma-client"
    output   = "../app/generated/prisma"
    // runtime  = "vercel-edge"
}

datasource db {
    provider = "postgresql"
    // url      = env("DATABASE_URL")
}

model Account {
    id                String  @id @default(cuid())
    userId            String  @map("user_id")
    type              String
    provider          String
    providerAccountId String  @map("provider_account_id")
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique @map("session_token")
    userId       String   @map("user_id")
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime? @map("email_verified")
    password      String
    role          UserRole  @default(USER)
    image         String?

    phone   String?
    address String?
    city    String?
    country String?
    bio     String? @db.Text

    // Câmpuri pentru PROFESOR (opționale - doar dacă role = PROFESOR)
    firstname String? // Prenume
    lastname  String? // Nume de familie
    title     String? // ex: "Dr.", "Prof. Dr."
    grade     String? // ex: "Conferențiar", "Lector"

    // Câmpuri pentru STUDENT (opționale - doar dacă role = STUDENT)
    publicId String? @unique // Cod de identificare public (pentru GDPR - afișare note publice)

    // Date personale (pentru studenți)
    sex           Sex?
    cnpEncrypted  String? // CNP criptat pentru securitate
    birthDate     DateTime?
    birthPlace    String?
    ethnicity     String?
    religion      String?
    citizenship   String? // default: "Română"
    maritalStatus String? // default: "Necăsătorit/ă"

    // Situație socială (pentru studenți)
    socialSituation        String?
    isOrphan               Boolean? @default(false)
    needsSpecialConditions Boolean? @default(false)

    // Familie
    parentsNames String?

    // Adresă rezidențială (pentru studenți - mai specific decât address)
    residentialAddress String?

    // Informații medicale (pentru studenți)
    specialMedicalCondition String?
    disability              Disability? @default(NONE)

    // Relație cu grup (pentru studenți)
    groupId String?
    group   Group?  @relation("UserGroup", fields: [groupId], references: [id], onDelete: SetNull)

    accounts      Account[]
    sessions      Session[]
    logs          Log[]
    notifications Notification[] @relation("UserNotifications")

    // DEPRECATED - Legăturile vechi cu Teacher și Student (vor fi șterse după migrare)
    teacherProfile Teacher? @relation("UserAsTeacher")
    studentProfile Student? @relation("UserAsStudent")

    // Relații pentru mesagerie
    conversationParticipants ConversationParticipant[]
    sentMessages             Message[]                 @relation("MessageSender")
    messageReactions         MessageReaction[]         @relation("UserMessageReactions")

    // Relații pentru entități create/actualizate
    createdEvents      Event[]      @relation("EventCreatedBy")
    updatedEvents      Event[]      @relation("EventUpdatedBy")
    approvedEvents     Event[]      @relation("EventApprovedBy")
    publishedEvents    Event[]      @relation("EventPublishedBy")
    createdTeachers    Teacher[]    @relation("TeacherCreatedBy")
    updatedTeachers    Teacher[]    @relation("TeacherUpdatedBy")
    createdDisciplines Discipline[] @relation("DisciplineCreatedBy")
    updatedDisciplines Discipline[] @relation("DisciplineUpdatedBy")
    createdGroups      Group[]      @relation("GroupCreatedBy")
    updatedGroups      Group[]      @relation("GroupUpdatedBy")
    createdClassrooms  Classroom[]  @relation("ClassroomCreatedBy")
    updatedClassrooms  Classroom[]  @relation("ClassroomUpdatedBy")
    createdStudents    Student[]    @relation("StudentCreatedBy")
    updatedStudents    Student[]    @relation("StudentUpdatedBy")

    // Relații pentru noi funcționalități
    teachingDisciplines   Discipline[]     @relation("UserTeachingDisciplines") // Discipline predate de profesor
    grades                Grade[]          @relation("UserGrades") // Note primite de student
    studentDisciplines    StudentDiscipline[] @relation("UserStudentDisciplines") // Discipline la care e înscris studentul
    uploadedCourseMaterials CourseMaterial[] @relation("UserUploadedMaterials") // Materiale încărcate de profesor
    createdExams          Exam[]           @relation("UserCreatedExams") // Examene create de profesor
    givenGrades           Grade[]          @relation("UserGivenGrades") // Note date de profesor

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("users")
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@unique([identifier, token])
    @@map("verification_tokens")
}

enum UserRole {
    ADMIN
    SECRETAR
    PROFESOR
    STUDENT
    USER
}

enum EventStatus {
    DRAFT
    PENDING_APPROVAL
    APPROVED
    PUBLISHED
    REJECTED
}

model AcademicYear {
    id        String   @id @default(cuid())
    start     Int
    end       Int
    published Boolean  @default(false)
    events    Event[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([start, end])
    @@map("academic_years")
}

model LearningType {
    id            String       @id @default(cuid())
    learningCycle String       @unique
    events        Event[]
    studyYears    StudyYear[]
    disciplines   Discipline[]
    groups        Group[]
    createdAt     DateTime     @default(now())
    updatedAt     DateTime     @updatedAt

    @@map("learning_types")
}

model StudyYear {
    id             String       @id @default(cuid())
    year           Int // 1, 2, or 3
    learningTypeId String
    learningType   LearningType @relation(fields: [learningTypeId], references: [id])
    studentGroups  Group[]
    disciplines    Discipline[]

    @@unique([learningTypeId, year])
    @@map("study_years")
}

model Teacher {
    id          String       @id @default(cuid())
    firstname   String
    lastname    String
    image       String?
    email       String
    phone       String?
    title       String?
    grade       String?
    events      Event[]
    disciplines Discipline[]

    // Legătura cu User
    user   User?   @relation("UserAsTeacher", fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    createdBy   User?   @relation("TeacherCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("TeacherUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([email, phone])
    @@map("teachers")
}

model Classroom {
    id       String  @id @default(cuid())
    name     String  @unique
    capacity Int?    @default(0)
    building String?
    events   Event[]

    createdBy   User?   @relation("ClassroomCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("ClassroomUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("classrooms")
}

model Discipline {
    id             String              @id @default(cuid())
    name           String

    // DEPRECATED - teacherId vechi (va fi șters după migrare)
    teacherId      String?
    teacher        Teacher?            @relation(fields: [teacherId], references: [id], onDelete: Cascade)

    // NOU - profesor ca User direct
    professorId    String?
    professor      User?               @relation("UserTeachingDisciplines", fields: [professorId], references: [id], onDelete: Cascade)

    learningTypeId String?
    learningType   LearningType?       @relation(fields: [learningTypeId], references: [id], onDelete: Cascade)
    studyYearId    String
    studyYear      StudyYear           @relation(fields: [studyYearId], references: [id], onDelete: Cascade)
    semester       Int                 @default(1)
    events         Event[]
    grades         Grade[]
    students       StudentDiscipline[]
    courseMaterials CourseMaterial[]   // Materiale de curs
    exams          Exam[]              // Examene

    createdBy   User?   @relation("DisciplineCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("DisciplineUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("disciplines")
}

model Event {
    id        String @id @default(cuid())
    day       Day
    startHour String // ex: "08:00"
    endHour   String // ex: "10:00"
    duration  Int? // in hours

    academicYear   AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
    academicYearId String // ex: "2025-2026"

    semester Int @default(1) // 1 or 2

    eventType       String // ex: "Curs", "Seminar", etc.
    eventRecurrence String? // ex: "Toate saptamanile", "Saptamani pare", "Saptamani impare".

    learnings  LearningType @relation(fields: [learningId], references: [id], onDelete: Cascade)
    learningId String // ex: "Licenta", "Master"

    teacher   Teacher @relation(fields: [teacherId], references: [id], onDelete: Cascade)
    teacherId String // ex: "Prof. Dr. Ion Popescu"

    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    disciplineId String // ex: "Tehnologii Web"

    classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
    classroomId String // ex: "A101"

    groups EventGroup[]

    // Workflow status and approval tracking
    status          EventStatus @default(DRAFT)
    approvedBy      User?       @relation("EventApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
    approvedById    String?
    approvedAt      DateTime?
    publishedBy     User?       @relation("EventPublishedBy", fields: [publishedById], references: [id], onDelete: SetNull)
    publishedById   String?
    publishedAt     DateTime?
    rejectionReason String?     @db.Text

    createdBy   User?   @relation("EventCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("EventUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([day, startHour])
    @@index([teacherId, day, startHour])
    @@index([classroomId, day, startHour])
    @@index([status])
    @@map("events")
}

model Group {
    id             String        @id @default(cuid())
    name           String
    group          Int           @default(1)
    learningTypeId String?
    learningType   LearningType? @relation(fields: [learningTypeId], references: [id], onDelete: Cascade)
    studyYearId    String
    studyYear      StudyYear     @relation(fields: [studyYearId], references: [id])
    semester       Int           @default(1)
    events         EventGroup[]

    // DEPRECATED - studenți vechi (va fi șters după migrare)
    students       Student[]

    // NOU - studenți ca User direct
    userStudents   User[]        @relation("UserGroup")

    createdBy   User?   @relation("GroupCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("GroupUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([studyYearId, name])
    @@map("groups")
}

model EventGroup {
    event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
    eventId String

    group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
    groupId String

    @@id([eventId, groupId]) // composite PK
    @@map("event_groups")
}

model Student {
    id        String  @id @default(cuid())
    firstname String
    lastname  String
    image     String?
    email     String  @unique

    // Cod de identificare public (pentru GDPR - afișare note publice)
    publicId String @unique

    // Date personale
    sex           Sex
    cnpEncrypted  String // CNP criptat pentru securitate
    birthDate     DateTime
    birthPlace    String
    ethnicity     String?
    religion      String?
    citizenship   String   @default("Română")
    maritalStatus String   @default("Necăsătorit/ă")

    // Situație socială
    socialSituation        String?
    isOrphan               Boolean @default(false)
    needsSpecialConditions Boolean @default(false)

    // Familie
    parentsNames String?

    // Adresă
    residentialAddress String?

    // Informații medicale
    specialMedicalCondition String?
    disability              Disability @default(NONE)

    // Legătura cu User
    user   User?   @relation("UserAsStudent", fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    // Relații
    groupId String?
    group   Group?  @relation(fields: [groupId], references: [id], onDelete: SetNull)

    grades            Grade[]
    studentDiscipline StudentDiscipline[]

    createdBy   User?   @relation("StudentCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("StudentUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("students")
}

model StudentDiscipline {
    id           String     @id @default(cuid()) // ID unic pentru a evita probleme cu migrarea

    // DEPRECATED - student vechi (va fi șters după migrare)
    student      Student?   @relation(fields: [studentId], references: [id], onDelete: Cascade)
    studentId    String?

    // NOU - user ca student
    user         User?      @relation("UserStudentDisciplines", fields: [userId], references: [id], onDelete: Cascade)
    userId       String?

    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    disciplineId String

    enrolledAt   DateTime   @default(now()) // Data înscrierii la disciplină

    @@unique([disciplineId, userId])
    @@unique([disciplineId, studentId]) // Pentru compatibilitate temporară
    @@map("student_disciplines")
}

model Grade {
    id           String     @id @default(cuid())
    value        Float // Nota (ex: 10, 9.5, etc.)
    gradeType    String // ex: "Examen", "Colocviu", "Laborator", "Prezentare", "Activitate"
    date         DateTime   @default(now())
    feedback     String?    @db.Text // Feedback de la profesor

    // DEPRECATED - student vechi (va fi șters după migrare)
    studentId    String?
    student      Student?   @relation(fields: [studentId], references: [id], onDelete: Cascade)

    // NOU - user ca student
    userId       String?
    user         User?      @relation("UserGrades", fields: [userId], references: [id], onDelete: Cascade)

    disciplineId String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)

    // Relație cu examen (opțional - doar pentru note de examen)
    examId       String?
    exam         Exam?      @relation(fields: [examId], references: [id], onDelete: SetNull)

    // Profesor care a dat nota
    professorId  String?
    professor    User?      @relation("UserGivenGrades", fields: [professorId], references: [id], onDelete: SetNull)

    createdAt    DateTime   @default(now())
    updatedAt    DateTime   @updatedAt

    @@index([userId, disciplineId])
    @@index([studentId, disciplineId]) // Pentru compatibilitate temporară
    @@index([examId])
    @@map("grades")
}

model CourseMaterial {
    id          String     @id @default(cuid())
    title       String
    description String?    @db.Text

    // Disciplina la care aparține materialul
    disciplineId String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)

    // Fișier
    fileUrl      String     // URL către fișier (stocat în UploadThing sau alt storage)
    fileName     String
    fileSize     Int?       // în bytes
    mimeType     String?

    // Categorie (Curs, Seminar, Laborator, Altele)
    category     String     @default("Curs")

    // Vizibilitate
    isPublished  Boolean    @default(true) // Dacă este vizibil pentru studenți

    // Profesor care a încărcat materialul
    uploadedById String
    uploadedBy   User       @relation("UserUploadedMaterials", fields: [uploadedById], references: [id], onDelete: Cascade)

    createdAt    DateTime   @default(now())
    updatedAt    DateTime   @updatedAt

    @@index([disciplineId])
    @@index([uploadedById])
    @@map("course_materials")
}

model Exam {
    id          String     @id @default(cuid())
    title       String
    description String?    @db.Text

    // Disciplina la care aparține examenul
    disciplineId String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)

    // Data și durata
    examDate     DateTime
    duration     Int?       // Durata în minute
    location     String?    // Sala de examen

    // Tip examen (Examen, Colocviu, Parțial, Test)
    examType     String     @default("Examen")

    // Punctaj maxim
    maxScore     Float      @default(10)

    // Instrucțiuni și observații
    instructions String?    @db.Text
    notes        String?    @db.Text

    // Vizibilitate
    isPublished  Boolean    @default(false) // Dacă este vizibil pentru studenți

    // Note asociate examenului
    grades       Grade[]

    // Profesor care a creat examenul
    createdById  String
    createdBy    User       @relation("UserCreatedExams", fields: [createdById], references: [id], onDelete: Cascade)

    createdAt    DateTime   @default(now())
    updatedAt    DateTime   @updatedAt

    @@index([disciplineId])
    @@index([examDate])
    @@index([createdById])
    @@map("exams")
}

model Log {
    id        String   @id @default(cuid())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    String
    action    String
    resource  String
    details   String?
    createdAt DateTime @default(now())

    @@map("logs")
}

model Notification {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
    title     String
    message   String
    read      Boolean  @default(false)
    type      String   @default("INFO") // INFO, SUCCESS, WARNING, ERROR
    createdAt DateTime @default(now())

    @@index([userId, read])
    @@map("notifications")
}

enum Day {
    LUNI
    MARTI
    MIERCURI
    JOI
    VINERI
    SAMBATA
    DUMINICA
}

enum LearningTypes {
    CURS
    SEMINAR
    LABORATOR
    PRACTICA
}

enum Sex {
    MASCULIN
    FEMININ
}

enum Disability {
    NONE
    GRAD_1
    GRAD_2
}

enum ConversationType {
    DIRECT
    GROUP
}

enum MessageType {
    TEXT
    IMAGE
    FILE
    VOICE
}

enum AttachmentType {
    IMAGE
    FILE
    VOICE
}

model Conversation {
    id           String                    @id @default(cuid())
    type         ConversationType          @default(DIRECT)
    title        String? // pentru conversații de grup
    participants ConversationParticipant[]
    messages     Message[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("conversations")
}

model ConversationParticipant {
    id             String       @id @default(cuid())
    conversationId String
    conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Ultima dată când utilizatorul a citit conversația
    lastReadAt DateTime?

    joinedAt DateTime @default(now())

    @@unique([conversationId, userId])
    @@index([userId])
    @@map("conversation_participants")
}

model Message {
    id             String       @id @default(cuid())
    conversationId String
    conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
    senderId       String
    sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

    type    MessageType @default(TEXT)
    content String      @db.Text

    // Pentru mesaje editate/șterse
    isEdited  Boolean @default(false)
    isDeleted Boolean @default(false)

    // Relații
    attachments MessageAttachment[]
    reactions   MessageReaction[]

    // Reply to message
    replyToId String?
    replyTo   Message?  @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
    replies   Message[] @relation("MessageReplies")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([conversationId, createdAt])
    @@index([senderId])
    @@map("messages")
}

model MessageAttachment {
    id        String  @id @default(cuid())
    messageId String
    message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

    type     AttachmentType
    url      String // URL către fișier (stocat în UploadThing sau alt storage)
    fileName String?
    fileSize Int? // în bytes
    mimeType String?

    // Pentru mesaje vocale
    duration Int? // în secunde

    // Pentru imagini
    width  Int?
    height Int?

    createdAt DateTime @default(now())

    @@index([messageId])
    @@map("message_attachments")
}

model MessageReaction {
    id        String  @id @default(cuid())
    messageId String
    message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
    userId    String
    user      User    @relation("UserMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

    emoji String // emoji unicode sau :emoji_name:

    createdAt DateTime @default(now())

    @@unique([messageId, userId, emoji])
    @@index([messageId])
    @@map("message_reactions")
}
