// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
    provider = "prisma-client"
    output   = "../app/generated/prisma"
    // runtime  = "vercel-edge"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Account {
    id                String  @id @default(cuid())
    userId            String  @map("user_id")
    type              String
    provider          String
    providerAccountId String  @map("provider_account_id")
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique @map("session_token")
    userId       String   @map("user_id")
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime? @map("email_verified")
    password      String
    role          UserRole  @default(USER)
    image         String?

    phone   String?
    address String?
    city    String?
    country String?
    bio     String? @db.Text

    accounts Account[]
    sessions Session[]
    logs     Log[]
    notifications Notification[] @relation("UserNotifications")

    // Legăturile cu Teacher și Student
    teacherProfile Teacher? @relation("UserAsTeacher")
    studentProfile Student? @relation("UserAsStudent")

    // Relații pentru mesagerie
    conversationParticipants ConversationParticipant[]
    sentMessages             Message[]                  @relation("MessageSender")

    createdEvents      Event[]      @relation("EventCreatedBy")
    updatedEvents      Event[]      @relation("EventUpdatedBy")
    approvedEvents     Event[]      @relation("EventApprovedBy")
    publishedEvents    Event[]      @relation("EventPublishedBy")
    createdTeachers    Teacher[]    @relation("TeacherCreatedBy")
    updatedTeachers    Teacher[]    @relation("TeacherUpdatedBy")
    createdDisciplines Discipline[] @relation("DisciplineCreatedBy")
    updatedDisciplines Discipline[] @relation("DisciplineUpdatedBy")
    createdGroups      Group[]      @relation("GroupCreatedBy")
    updatedGroups      Group[]      @relation("GroupUpdatedBy")
    createdClassrooms  Classroom[]  @relation("ClassroomCreatedBy")
    updatedClassrooms  Classroom[]  @relation("ClassroomUpdatedBy")
    createdStudents    Student[]    @relation("StudentCreatedBy")
    updatedStudents    Student[]    @relation("StudentUpdatedBy")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("users")
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@unique([identifier, token])
    @@map("verification_tokens")
}

enum UserRole {
    ADMIN
    SECRETAR
    PROFESOR
    STUDENT
    USER
}

enum EventStatus {
    DRAFT
    PENDING_APPROVAL
    APPROVED
    PUBLISHED
    REJECTED
}

model AcademicYear {
    id        String   @id @default(cuid())
    start     Int
    end       Int
    published Boolean  @default(false)
    events    Event[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([start, end])
    @@map("academic_years")
}

model LearningType {
    id            String       @id @default(cuid())
    learningCycle String       @unique
    events        Event[]
    studyYears    StudyYear[]
    disciplines   Discipline[]
    groups        Group[]
    createdAt     DateTime     @default(now())
    updatedAt     DateTime     @updatedAt

    @@map("learning_types")
}

model StudyYear {
    id             String       @id @default(cuid())
    year           Int // 1, 2, or 3
    learningTypeId String
    learningType   LearningType @relation(fields: [learningTypeId], references: [id])
    studentGroups  Group[]
    disciplines    Discipline[]

    @@unique([learningTypeId, year])
    @@map("study_years")
}

model Teacher {
    id          String       @id @default(cuid())
    firstname   String
    lastname    String
    image       String?
    email       String
    phone       String?
    title       String?
    grade       String?
    events      Event[]
    disciplines Discipline[]

    // Legătura cu User
    user        User?   @relation("UserAsTeacher", fields: [userId], references: [id], onDelete: Cascade)
    userId      String? @unique

    createdBy   User?   @relation("TeacherCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("TeacherUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([email, phone])
    @@map("teachers")
}

model Classroom {
    id       String  @id @default(cuid())
    name     String  @unique
    capacity Int?    @default(0)
    building String?
    events   Event[]

    createdBy   User?   @relation("ClassroomCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("ClassroomUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("classrooms")
}

model Discipline {
    id             String        @id @default(cuid())
    name           String
    teacherId      String
    teacher        Teacher       @relation(fields: [teacherId], references: [id], onDelete: Cascade)
    learningTypeId String?
    learningType   LearningType? @relation(fields: [learningTypeId], references: [id], onDelete: Cascade)
    studyYearId    String
    studyYear      StudyYear     @relation(fields: [studyYearId], references: [id], onDelete: Cascade)
    semester       Int           @default(1)
    events         Event[]
    grades         Grade[]
    students       StudentDiscipline[]

    createdBy   User?   @relation("DisciplineCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("DisciplineUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("disciplines")
}

model Event {
    id        String @id @default(cuid())
    day       Day
    startHour String // ex: "08:00"
    endHour   String // ex: "10:00"
    duration  Int? // in hours

    academicYear   AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
    academicYearId String // ex: "2025-2026"

    semester Int @default(1) // 1 or 2

    eventType       String // ex: "Curs", "Seminar", etc.
    eventRecurrence String? // ex: "Toate saptamanile", "Saptamani pare", "Saptamani impare".

    learnings  LearningType @relation(fields: [learningId], references: [id], onDelete: Cascade)
    learningId String // ex: "Licenta", "Master"

    teacher   Teacher @relation(fields: [teacherId], references: [id], onDelete: Cascade)
    teacherId String // ex: "Prof. Dr. Ion Popescu"

    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    disciplineId String // ex: "Tehnologii Web"

    classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
    classroomId String // ex: "A101"

    groups EventGroup[]

    // Workflow status and approval tracking
    status           EventStatus @default(DRAFT)
    approvedBy       User?       @relation("EventApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
    approvedById     String?
    approvedAt       DateTime?
    publishedBy      User?       @relation("EventPublishedBy", fields: [publishedById], references: [id], onDelete: SetNull)
    publishedById    String?
    publishedAt      DateTime?
    rejectionReason  String?     @db.Text

    createdBy   User?   @relation("EventCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("EventUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([day, startHour])
    @@index([teacherId, day, startHour])
    @@index([classroomId, day, startHour])
    @@index([status])
    @@map("events")
}

model Group {
    id             String        @id @default(cuid())
    name           String
    group          Int           @default(1)
    learningTypeId String?
    learningType   LearningType? @relation(fields: [learningTypeId], references: [id], onDelete: Cascade)
    studyYearId    String
    studyYear      StudyYear     @relation(fields: [studyYearId], references: [id])
    semester       Int           @default(1)
    events         EventGroup[]
    students       Student[]

    createdBy   User?   @relation("GroupCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("GroupUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([studyYearId, name])
    @@map("groups")
}

model EventGroup {
    event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
    eventId String

    group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
    groupId String

    @@id([eventId, groupId]) // composite PK
    @@map("event_groups")
}

model Student {
    id        String  @id @default(cuid())
    firstname String
    lastname  String
    image     String?
    email     String  @unique

    // Cod de identificare public (pentru GDPR - afișare note publice)
    publicId String @unique

    // Date personale
    sex           Sex
    cnpEncrypted  String // CNP criptat pentru securitate
    birthDate     DateTime
    birthPlace    String
    ethnicity     String?
    religion      String?
    citizenship   String  @default("Română")
    maritalStatus String  @default("Necăsătorit/ă")

    // Situație socială
    socialSituation        String?
    isOrphan               Boolean @default(false)
    needsSpecialConditions Boolean @default(false)

    // Familie
    parentsNames String?

    // Adresă
    residentialAddress String?

    // Informații medicale
    specialMedicalCondition String?
    disability              Disability @default(NONE)

    // Legătura cu User
    user        User?   @relation("UserAsStudent", fields: [userId], references: [id], onDelete: Cascade)
    userId      String? @unique

    // Relații
    groupId String?
    group   Group?  @relation(fields: [groupId], references: [id], onDelete: SetNull)

    grades            Grade[]
    studentDiscipline StudentDiscipline[]

    createdBy   User?   @relation("StudentCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("StudentUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("students")
}

model StudentDiscipline {
    student      Student    @relation(fields: [studentId], references: [id], onDelete: Cascade)
    studentId    String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    disciplineId String

    @@id([studentId, disciplineId])
    @@map("student_disciplines")
}

model Grade {
    id           String   @id @default(cuid())
    value        Float // Nota (ex: 10, 9.5, etc.)
    gradeType    String // ex: "Examen", "Colocviu", "Laborator", "Prezentare"
    date         DateTime @default(now())
    studentId    String
    student      Student  @relation(fields: [studentId], references: [id], onDelete: Cascade)
    disciplineId String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    @@index([studentId, disciplineId])
    @@map("grades")
}

model Log {
    id        String   @id @default(cuid())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    String
    action    String
    resource  String
    details   String?
    createdAt DateTime @default(now())

    @@map("logs")
}

model Notification {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
    title     String
    message   String
    read      Boolean  @default(false)
    type      String   @default("INFO") // INFO, SUCCESS, WARNING, ERROR
    createdAt DateTime @default(now())

    @@index([userId, read])
    @@map("notifications")
}

enum Day {
    LUNI
    MARTI
    MIERCURI
    JOI
    VINERI
    SAMBATA
    DUMINICA
}

enum LearningTypes {
    CURS
    SEMINAR
    LABORATOR
    PRACTICA
}

enum Sex {
    MASCULIN
    FEMININ
}

enum Disability {
    NONE
    GRAD_1
    GRAD_2
}

enum ConversationType {
    DIRECT
    GROUP
}

model Conversation {
    id           String                    @id @default(cuid())
    type         ConversationType          @default(DIRECT)
    title        String? // pentru conversații de grup
    participants ConversationParticipant[]
    messages     Message[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("conversations")
}

model ConversationParticipant {
    id             String       @id @default(cuid())
    conversationId String
    conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Ultima dată când utilizatorul a citit conversația
    lastReadAt DateTime?

    joinedAt DateTime @default(now())

    @@unique([conversationId, userId])
    @@index([userId])
    @@map("conversation_participants")
}

model Message {
    id             String       @id @default(cuid())
    conversationId String
    conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
    senderId       String
    sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
    content        String       @db.Text

    // Pentru mesaje editate/șterse
    isEdited  Boolean @default(false)
    isDeleted Boolean @default(false)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([conversationId, createdAt])
    @@index([senderId])
    @@map("messages")
}
