// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
    provider = "prisma-client"
    output   = "../app/generated/prisma"
    // runtime  = "vercel-edge"
}

datasource db {
    provider = "postgresql"
    // url      = env("DATABASE_URL")
}

model Account {
    id                String  @id @default(cuid())
    userId            String  @map("user_id")
    type              String
    provider          String
    providerAccountId String  @map("provider_account_id")
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique @map("session_token")
    userId       String   @map("user_id")
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@map("sessions")
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime? @map("email_verified")
    password      String
    role          UserRole  @default(USER)
    image         String?

    phone   String?
    address String?
    city    String?
    country String?
    bio     String? @db.Text

    accounts      Account[]
    sessions      Session[]
    logs          Log[]
    notifications Notification[] @relation("UserNotifications")

    // Legăturile cu profilurile specifice rolurilor
    teacherProfile   Teacher?   @relation("UserAsTeacher")
    studentProfile   Student?   @relation("UserAsStudent")
    secretaryProfile Secretary? @relation("UserAsSecretary")
    adminProfile     Admin?     @relation("UserAsAdmin")

    // Relații pentru mesagerie
    conversationParticipants ConversationParticipant[]
    sentMessages             Message[]                 @relation("MessageSender")
    messageReactions         MessageReaction[]         @relation("UserMessageReactions")

    createdEvents      Event[]      @relation("EventCreatedBy")
    updatedEvents      Event[]      @relation("EventUpdatedBy")
    approvedEvents     Event[]      @relation("EventApprovedBy")
    publishedEvents    Event[]      @relation("EventPublishedBy")
    createdTeachers    Teacher[]    @relation("TeacherCreatedBy")
    updatedTeachers    Teacher[]    @relation("TeacherUpdatedBy")
    createdDisciplines Discipline[] @relation("DisciplineCreatedBy")
    updatedDisciplines Discipline[] @relation("DisciplineUpdatedBy")
    createdGroups      Group[]      @relation("GroupCreatedBy")
    updatedGroups      Group[]      @relation("GroupUpdatedBy")
    createdClassrooms  Classroom[]  @relation("ClassroomCreatedBy")
    updatedClassrooms  Classroom[]  @relation("ClassroomUpdatedBy")
    createdStudents     Student[]    @relation("StudentCreatedBy")
    updatedStudents     Student[]    @relation("StudentUpdatedBy")
    createdSecretaries  Secretary[]  @relation("SecretaryCreatedBy")
    updatedSecretaries  Secretary[]  @relation("SecretaryUpdatedBy")
    createdAdmins       Admin[]      @relation("AdminCreatedBy")
    updatedAdmins       Admin[]      @relation("AdminUpdatedBy")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("users")
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@unique([identifier, token])
    @@map("verification_tokens")
}

enum UserRole {
    ADMIN
    SECRETAR
    PROFESOR
    STUDENT
    USER
}

enum EventStatus {
    DRAFT
    PENDING_APPROVAL
    APPROVED
    PUBLISHED
    REJECTED
}

model AcademicYear {
    id        String   @id @default(cuid())
    start     Int
    end       Int
    published Boolean  @default(false)
    events    Event[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([start, end])
    @@map("academic_years")
}

model LearningType {
    id            String       @id @default(cuid())
    learningCycle String       @unique
    events        Event[]
    studyYears    StudyYear[]
    disciplines   Discipline[]
    groups        Group[]
    createdAt     DateTime     @default(now())
    updatedAt     DateTime     @updatedAt

    @@map("learning_types")
}

model StudyYear {
    id             String       @id @default(cuid())
    year           Int // 1, 2, or 3
    learningTypeId String
    learningType   LearningType @relation(fields: [learningTypeId], references: [id])
    studentGroups  Group[]
    disciplines    Discipline[]

    @@unique([learningTypeId, year])
    @@map("study_years")
}

model Teacher {
    id          String       @id @default(cuid())
    firstname   String
    lastname    String
    image       String?
    email       String
    phone       String?

    // Informații academice
    title     String? // Titlu academic (e.g., "Dr.", "Prof. Dr.", "Conf. Dr.")
    grade     String? // Grad didactic (e.g., "Profesor Universitar", "Conferențiar", "Lector")
    education String? @db.Text // Studii complete (e.g., "Doctorat în Informatică - Universitatea București, 2015\nMaster în AI - ...")

    events      Event[]
    disciplines Discipline[]

    // Legătura cu User
    user   User?   @relation("UserAsTeacher", fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    createdBy   User?   @relation("TeacherCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("TeacherUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([email, phone])
    @@map("teachers")
}

model Classroom {
    id       String  @id @default(cuid())
    name     String  @unique
    capacity Int?    @default(0)
    building String?
    events   Event[]

    createdBy   User?   @relation("ClassroomCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("ClassroomUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("classrooms")
}

model Discipline {
    id             String              @id @default(cuid())
    name           String
    teacherId      String
    teacher        Teacher             @relation(fields: [teacherId], references: [id], onDelete: Cascade)
    learningTypeId String?
    learningType   LearningType?       @relation(fields: [learningTypeId], references: [id], onDelete: Cascade)
    studyYearId    String
    studyYear      StudyYear           @relation(fields: [studyYearId], references: [id], onDelete: Cascade)
    semester       Int                 @default(1)
    events         Event[]
    grades         Grade[]
    students       StudentDiscipline[]

    createdBy   User?   @relation("DisciplineCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("DisciplineUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("disciplines")
}

model Event {
    id        String @id @default(cuid())
    day       Day
    startHour String // ex: "08:00"
    endHour   String // ex: "10:00"
    duration  Int? // in hours

    academicYear   AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
    academicYearId String // ex: "2025-2026"

    semester Int @default(1) // 1 or 2

    eventType       String // ex: "Curs", "Seminar", etc.
    eventRecurrence String? // ex: "Toate saptamanile", "Saptamani pare", "Saptamani impare".

    learnings  LearningType @relation(fields: [learningId], references: [id], onDelete: Cascade)
    learningId String // ex: "Licenta", "Master"

    teacher   Teacher @relation(fields: [teacherId], references: [id], onDelete: Cascade)
    teacherId String // ex: "Prof. Dr. Ion Popescu"

    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    disciplineId String // ex: "Tehnologii Web"

    classroom   Classroom @relation(fields: [classroomId], references: [id], onDelete: Cascade)
    classroomId String // ex: "A101"

    groups EventGroup[]

    // Workflow status and approval tracking
    status          EventStatus @default(DRAFT)
    approvedBy      User?       @relation("EventApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
    approvedById    String?
    approvedAt      DateTime?
    publishedBy     User?       @relation("EventPublishedBy", fields: [publishedById], references: [id], onDelete: SetNull)
    publishedById   String?
    publishedAt     DateTime?
    rejectionReason String?     @db.Text

    createdBy   User?   @relation("EventCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("EventUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([day, startHour])
    @@index([teacherId, day, startHour])
    @@index([classroomId, day, startHour])
    @@index([status])
    @@map("events")
}

model Group {
    id             String        @id @default(cuid())
    name           String
    group          Int           @default(1)
    learningTypeId String?
    learningType   LearningType? @relation(fields: [learningTypeId], references: [id], onDelete: Cascade)
    studyYearId    String
    studyYear      StudyYear     @relation(fields: [studyYearId], references: [id])
    semester       Int           @default(1)
    events         EventGroup[]
    students       Student[]

    createdBy   User?   @relation("GroupCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("GroupUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([studyYearId, name])
    @@map("groups")
}

model EventGroup {
    event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
    eventId String

    group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
    groupId String

    @@id([eventId, groupId]) // composite PK
    @@map("event_groups")
}

model Student {
    id        String  @id @default(cuid())
    firstname String
    lastname  String
    image     String?
    email     String  @unique

    // Cod de identificare public (pentru GDPR - afișare note publice)
    publicId String @unique

    // Date personale
    sex           Sex
    cnpEncrypted  String // CNP criptat pentru securitate
    birthDate     DateTime
    birthPlace    String
    ethnicity     String?
    religion      String?
    citizenship   String   @default("Română")
    maritalStatus String   @default("Necăsătorit/ă")

    // Situație socială
    socialSituation        String?
    isOrphan               Boolean @default(false)
    needsSpecialConditions Boolean @default(false)

    // Familie
    parentsNames String?

    // Adresă
    residentialAddress String?

    // Informații medicale
    specialMedicalCondition String?
    disability              Disability @default(NONE)

    // Legătura cu User
    user   User?   @relation("UserAsStudent", fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    // Relații
    groupId String?
    group   Group?  @relation(fields: [groupId], references: [id], onDelete: SetNull)

    grades            Grade[]
    studentDiscipline StudentDiscipline[]

    createdBy   User?   @relation("StudentCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("StudentUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("students")
}

model Secretary {
    id        String  @id @default(cuid())
    firstname String
    lastname  String
    image     String?
    email     String  @unique
    phone     String?

    // Informații specifice secretarului/secretarei
    department       String? // Departament (e.g., "Secretariat Studenți", "Secretariat Didactic", "Secretariat Facultate")
    office           String? // Biroul/camera (e.g., "A101", "Corp C, et. 2", "Sala Secretariat")
    officePhone      String? // Telefon birou
    workSchedule     String? // Program de lucru (e.g., "Luni-Vineri: 08:00-16:00", "L-J: 8-16, V: 8-14")
    responsibilities String? @db.Text // Responsabilități/sarcini (e.g., "Gestionare documente studenți, Eliberare adeverințe, Programare examene")

    // Legătura cu User
    user   User?   @relation("UserAsSecretary", fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    createdBy   User?   @relation("SecretaryCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("SecretaryUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("secretaries")
}

model Admin {
    id        String  @id @default(cuid())
    firstname String
    lastname  String
    image     String?
    email     String  @unique
    phone     String?

    // Informații specifice administratorului
    department       String? // Departament (e.g., "IT", "Resurse Umane", "Academic", "Financiar")
    adminRole        String? // Rol specific (e.g., "Administrator IT", "Administrator Academic", "Administrator Sistem", "Administrator Baze de Date")
    officePhone      String? // Telefon birou
    responsibilities String? @db.Text // Responsabilități principale (e.g., "Administrare servere, Backup baze de date, Suport tehnic utilizatori")
    accessLevel      Int     @default(1) // Nivel de acces (1-5, unde 5 = acces complet la toate sistemele)

    // Legătura cu User
    user   User?   @relation("UserAsAdmin", fields: [userId], references: [id], onDelete: Cascade)
    userId String? @unique

    createdBy   User?   @relation("AdminCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
    createdById String?
    updatedBy   User?   @relation("AdminUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)
    updatedById String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("admins")
}

model StudentDiscipline {
    student      Student    @relation(fields: [studentId], references: [id], onDelete: Cascade)
    studentId    String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    disciplineId String

    @@id([studentId, disciplineId])
    @@map("student_disciplines")
}

model Grade {
    id           String     @id @default(cuid())
    value        Float // Nota (ex: 10, 9.5, etc.)
    gradeType    String // ex: "Examen", "Colocviu", "Laborator", "Prezentare"
    date         DateTime   @default(now())
    studentId    String
    student      Student    @relation(fields: [studentId], references: [id], onDelete: Cascade)
    disciplineId String
    discipline   Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
    createdAt    DateTime   @default(now())
    updatedAt    DateTime   @updatedAt

    @@index([studentId, disciplineId])
    @@map("grades")
}

model Log {
    id        String   @id @default(cuid())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    String
    action    String
    resource  String
    details   String?
    createdAt DateTime @default(now())

    @@map("logs")
}

model Notification {
    id        String   @id @default(cuid())
    userId    String
    user      User     @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
    title     String
    message   String
    read      Boolean  @default(false)
    type      String   @default("INFO") // INFO, SUCCESS, WARNING, ERROR
    createdAt DateTime @default(now())

    @@index([userId, read])
    @@map("notifications")
}

enum Day {
    LUNI
    MARTI
    MIERCURI
    JOI
    VINERI
    SAMBATA
    DUMINICA
}

enum LearningTypes {
    CURS
    SEMINAR
    LABORATOR
    PRACTICA
}

enum Sex {
    MASCULIN
    FEMININ
}

enum Disability {
    NONE
    GRAD_1
    GRAD_2
}

enum ConversationType {
    DIRECT
    GROUP
}

enum MessageType {
    TEXT
    IMAGE
    FILE
    VOICE
}

enum AttachmentType {
    IMAGE
    FILE
    VOICE
}

model Conversation {
    id           String                    @id @default(cuid())
    type         ConversationType          @default(DIRECT)
    title        String? // pentru conversații de grup
    participants ConversationParticipant[]
    messages     Message[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("conversations")
}

model ConversationParticipant {
    id             String       @id @default(cuid())
    conversationId String
    conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Ultima dată când utilizatorul a citit conversația
    lastReadAt DateTime?

    joinedAt DateTime @default(now())

    @@unique([conversationId, userId])
    @@index([userId])
    @@map("conversation_participants")
}

model Message {
    id             String       @id @default(cuid())
    conversationId String
    conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
    senderId       String
    sender         User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

    type    MessageType @default(TEXT)
    content String      @db.Text

    // Pentru mesaje editate/șterse
    isEdited  Boolean @default(false)
    isDeleted Boolean @default(false)

    // Relații
    attachments MessageAttachment[]
    reactions   MessageReaction[]

    // Reply to message
    replyToId String?
    replyTo   Message?  @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
    replies   Message[] @relation("MessageReplies")

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([conversationId, createdAt])
    @@index([senderId])
    @@map("messages")
}

model MessageAttachment {
    id        String  @id @default(cuid())
    messageId String
    message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

    type     AttachmentType
    url      String // URL către fișier (stocat în UploadThing sau alt storage)
    fileName String?
    fileSize Int? // în bytes
    mimeType String?

    // Pentru mesaje vocale
    duration Int? // în secunde

    // Pentru imagini
    width  Int?
    height Int?

    createdAt DateTime @default(now())

    @@index([messageId])
    @@map("message_attachments")
}

model MessageReaction {
    id        String  @id @default(cuid())
    messageId String
    message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
    userId    String
    user      User    @relation("UserMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

    emoji String // emoji unicode sau :emoji_name:

    createdAt DateTime @default(now())

    @@unique([messageId, userId, emoji])
    @@index([messageId])
    @@map("message_reactions")
}
